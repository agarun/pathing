<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Aaron Agarunov | Projects | Pathing</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,800,900|Roboto+Mono|Montserrat:400,500,700">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css">
    <link rel="stylesheet" href="css/style.css" />

  </head>
  <body>
    <div class="canvas-wrapper">
      <div class="container">
        <canvas id="canvas">
          Oops, does your browser support HTML5 Canvas?
        </canvas>

        <div class="main-panel">
          <div class="main-panel-column" id="intro">
            <h1>Pathing</h1>
            <p>
            Visualizing maze generation using <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Prim.27s_algorithm">randomized Prim's algorithm</a> and maze searching using <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first</a> and <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first</a> algorithms.
            </p>

          </div>
          <div class="main-panel-column">
            <div class="btn-panel">
              <div class="btn-panel-row">
                <div class="btn-panel-row-text"><small>Searching</small></div>
                <div class="btn-panel-row-link">
                  <button class="search" id="bfs">breadth-first</button>
                  <button class="search" id="dfs">depth-first</button>
                  <!-- <button class="search" id="astar">a star</button>
                  <button class="search" id="dijkstra">dijkstra</button> -->
                </div>
              </div>
              <div class="btn-panel-row">
                <div class="btn-panel-row-text"><small>Sources</small>
                  Choose <span class="start">start</span> and <span class="end">end</span> points for pathing. Corners are used by default.
                </div>
                <div class="btn-panel-row-link">
                  <button class="maze" id="randomize">randomize sources</button>
                </div>
              </div>
              <div class="btn-panel-row">
                <div class="btn-panel-row-text">
                  <small>Rebuild maze</small>
                  Make new passages in the void.
                </div>
                <div class="btn-panel-row-link">
                  <button class="maze" id="generate">regenerate maze</button>
                </div>
              </div>
            <!-- https://khan.github.io/KaTeX/ , Slack, Vimeo -->
            <!-- two differnet btn classes, randomize / regen are a bit wider and adjacent ?
            breadth/depth aren't centered either.? -->
          </div>
        </div>
      </div>
    </div>
  </div>

      <div class="container">
        <div class="readme">
          <h1>Intro</h1>
            <p>Interactive visualization of maze generation and graph traversal algorithms in JavaScript (ES6) and HTML5 Canvas. The maze is generated using randomized Prim's algorithm to build a minimum spanning tree based on minimum edge weights. The tree can be searched with depth-first and breadth-first traversal algorithms.</p>
          <h1>Mazes</h1>
            <h3>Graphs</h3>
            <p>This demonstration considers the entire grid as a weighted, undirected graph for pathfinding. It is undirected in that each node is assigned a collection of all of its neighboring nodes and edges. It is weighted in that each edge has a random float weight between 0 and 1 (exclusive). The maze is drawn as a graph: both nodes and edges are drawn to the canvas.</p>

            <h3>Prim's Algorithm</h3>
            <p>Prim's algorithm is a greedy algorithm. It observes each node's neighbors and compares each edge's weight. Then, it chooses the passage with the <strong>local minimum edge weight</strong> as its next path and walks to the next node. As it does this, it constructs a spanning tree of all the locally optimal nodes and edges it reaches. The result is a subgraph of the original fully connected graph. This <em>minimum</em> spanning tree has the lowest possible total edge weight.</p>

            <p>In randomized Prim's algorithm, the maze's edges are initialized with random edge weights. The maze is built in the direction of the local minimum edge weight (cheapest edge) at each node if and only if the extension would avoid creating a loop in the maze. In the case that Prim's compares edge weights and predicts a cycle, the next available local minimum edge weight is chosen.</p>

            <p>To keep track of the cells (graph nodes) that can potentially be incorporated into the minimum spanning tree, a <strong>frontier</strong> of cells that <em>wall in</em> the current position in the tree is maintained. This frontier is repeatedly explored, evaluated, and adjusted until the spanning tree contains all of the nodes.</p>

            <h3>Implementation</h3>
            <p>The randomized Prim's algorithm is implemented classically.</p>

            <p>First, a fully-connected graph is generated. Each node is assigned neighboring edges in each available direction. The <code>Edge</code> constructor initializes each edge with a random weight.</p>

            <p>In Prim's algorithm, generation arbitrarily starts from the top-left corner (canvas coordinates 0, 0). The algorithm adjusts a frontier of available cells, explores it for the lowest-weighted edge, draws the current node and chosen edge, and finally extends the minimum spanning tree. When the algorithm predicts a cycle, it backtracks to the next available node based on the frontier. This is made possible by keeping the <code>discovered</code> state of each node as a property on each <code>Node</code> instance. The loop is repeated until the spanning tree contains all of the nodes in the initial graph.</p>

            <p>The colors are based on the progress of maze generation. Lighter colors indicate the nodes and edges were placed earlier, and darker colors indicate late placement. Since it's very common for Prim's to run into cycles after most of the maze has been generated, you can expect to see how backtracking returns to random spots in the maze.</p>
          <h1>Searching</h1>
            <h3>Breadth-first</h3>
            <p>Breadth-first search visits every node's incident edges before descending to the next level of nodes ('siblings first').</p>

            <p>It is guaranteed to find the shortest path on an undirected graph. Visiting every increasingly distant node from the source eventually generates a unique path to the target with the smallest number of edges.</p>

            <p>Breadth-first search is implemented with a queue, which maintains the order for traversal. Dequeueing returns the earliest added node, allowing the search to continue exploring a particular level of the graph (breadth!) before considering nodes at lower levels.</p>

            <h3>Depth-first</h3>
            <p>Depth-first search also considers the neighbors of each node. After walking to a node, the search keeps traveling to the deepest level before backtracking ('children first' - visit the parent node's children first).<p>

            <p>It's implemented with a stack (explicit and iterative implementation here, but can also use an implicit stack using recursion).</p>

            <p>Depth-first search is not guaranteed to find the shortest-path from the source to the target - it might terminate with a suboptimal solution.</p>

            <h3>BFS versus DFS</h3>
            <p>In the worst case, both search algorithms visit each vertex at most once and cover each edge at least once. While they have the same worst-case time (O(|V| + |E|)) and space complexity (O(|V|)), they have different applications. BFS is guaranteed to find the shortest-path solution, but might be slower to reach the solution when the target node is far from the source node. DFS can potentially be more useful when the target node is far from the source node, but it typically finds suboptimal solutions and might also traverse the entire graph.</p>

            <h3>Implementation</h3>
            <p>Both BFS and DFS have simple iterative implementations. BFS makes use of a queue while DFS makes use of a stack. JavaScript's <code>setInterval()</code> is used to repeatedly draw traversal and generation to the canvas. <code>setInterval()</code> returns an ID value that can be fed to <code>clearInterval()</code> to cancel any building paths.</p>
        </div>

        <footer>
          <p>
            <div class="icons">
              <a href="https://github.com/agarun/pathing" target="_blank">
                <svg class="icons" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
              </a>
              &middot;
              <a href="https://agarun.com" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.092 512.092" width="16" height="16"><path d="M312.453 199.601a116.167 116.167 0 0 0-20.053-16.128 119.472 119.472 0 0 0-64.427-18.859 118.952 118.952 0 0 0-84.48 34.987L34.949 308.23a119.466 119.466 0 0 0-34.91 84.318c-.042 65.98 53.41 119.501 119.39 119.543a118.7 118.7 0 0 0 84.395-34.816l89.6-89.6a8.534 8.534 0 0 0-6.059-14.592h-3.413a143.626 143.626 0 0 1-54.613-10.581 8.533 8.533 0 0 0-9.301 1.877l-64.427 64.512c-20.006 20.006-52.442 20.006-72.448 0-20.006-20.006-20.006-52.442 0-72.448l108.971-108.885c19.99-19.965 52.373-19.965 72.363 0 13.472 12.679 34.486 12.679 47.957 0a34.134 34.134 0 0 0 9.899-21.675 34.137 34.137 0 0 0-9.9-26.282z"/><path d="M477.061 34.993c-46.657-46.657-122.303-46.657-168.96 0l-89.515 89.429a8.533 8.533 0 0 0-1.792 9.387 8.532 8.532 0 0 0 8.021 5.205h3.157a143.357 143.357 0 0 1 54.528 10.667 8.533 8.533 0 0 0 9.301-1.877l64.256-64.171c20.006-20.006 52.442-20.006 72.448 0 20.006 20.006 20.006 52.442 0 72.448l-80.043 79.957-.683.768-27.989 27.819c-19.99 19.965-52.373 19.965-72.363 0-13.472-12.679-34.486-12.679-47.957 0a34.139 34.139 0 0 0-9.899 21.845 34.137 34.137 0 0 0 9.899 26.283 118.447 118.447 0 0 0 34.133 23.893c1.792.853 3.584 1.536 5.376 2.304 1.792.768 3.669 1.365 5.461 2.048a67.799 67.799 0 0 0 5.461 1.792l5.035 1.365c3.413.853 6.827 1.536 10.325 2.133 4.214.626 8.458 1.025 12.715 1.195H284.461l5.12-.597c1.877-.085 3.84-.512 6.059-.512h2.901l5.888-.853 2.731-.512 4.949-1.024h.939a119.456 119.456 0 0 0 55.381-31.403l108.629-108.629c46.66-46.657 46.66-122.303.003-168.96z"/>
                </svg>
              </a>
            &middot;
            <a href="https://agarun.com" target="_blank">Aaron Agarunov</a>
            &middot;
            <a href="https://github.com/agarun/pathing" target="_blank">GitHub</a>
          </p>
        </div>
      </div>
      </footer>
    <script src="public/bundle.js"></script>
  </body>
</html>
